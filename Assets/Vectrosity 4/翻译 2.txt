Vectrosity发布说明
　　- - - - - - - - - - - - - - - - - - - - - - - -
　　
　　Vectrosity 3.0
　　
　　添加:
　　 VectorLine.GetColor,它返回一个指定的线段的颜色。
　　 VectorLine.SetWidth 功能,设置指定的线段的线宽。
　　•VectorLine.GetWidth 函数,它返回指定的线段的线宽。
　　•VectorLine.collider 属性,它添加了一个2 d对撞机时画一条线。仅适用于画,而不是Draw3D。需要统一4.3或更高版本。
　　•VectorLine.physicsMaterial 属性,设置PhysicsMaterial2D对撞机。需要统一4.3或更高版本。
　　•VectorLine.sortingLayerID VectorLine.sortingOrder,获取和设置排序层和order-in-layer行。这些控制绘图命令以同样的方式,他们为精灵,并可用于确定绘图命令行与精灵混合时,以及其他行。需要统一4.3或更高版本。
　　•VectorLine.matrix,这就像画一条线,通过转换,除了你提供自己的矩阵。所以画的线将修改提供的矩阵。
　　
　　变化:
　　•需要统一4.0最低了,4.3统一一些函数(如上所述)。
　　•的精神”就把事情一旦当创建线,忘掉它,“一些函数和函数重载已被拆除,取而代之的是属性(见升级指南更多细节):
　　　　-删除SetTextureScale,添加textureScale textureOffset属性。而不是“SetTextureScale(1.0)”,做“myLine。textureScale = 1.0”,纹理规模将自动使用画()时,而不必手动调用SetTextureScale。同样,使用“myLine。textureOffset 0.5 = 0.5”而不是通过SetTextureScale。
　　-删除 Draw/Draw3D,接受改变,并添加drawTransform 属性。而不是"Draw (transform)”,做“myLine.drawTransform = transform”创建线后,用Draw/Draw3D正常。
　　-删除DrawViewport功能和添加useViewportCoords 属性。而不是“DrawViewport()”,做“myLine。useViewportCoords = true”创建线后,正常使用绘制函数。
　　-删除DrawViewport功能和添加useViewportCoords 属性。而不是“DrawViewport()”,做“myLine。useViewportCoords = true”创建线后,正常使用绘制函数。
　　•VectorLine.SetEndCap可以采取一个偏移值,这将抵消前后帽帽的百分比的长度。例如,使用-1.0抵消将减去100%上限的长度,这样线将只要没有上限。(因为结束端点通常添加到线的长度,如果你使用0.0的抵消)。
　　•VectorLine.Destroy可以接受数组或通用VectorLines / VectorPoints列表。
　　•VectorLine值为0的maxDrawIndex不再意味着“画所有的点”。相反,它的设置为“点阵列的长度减去1”默认情况下。现在使用0意味着“不画任何点”。
　　•删除VectorLine.useMeshQuads,因为使用它,没有真正的优势和潜在的缺点取决于平台。
　　
　　修复:
　　•固定连接的“修复”。填补Vectrosity 2.3 /三角形无关的问题,所以现在工作(雷亚尔)。
　　•固定问题,线路使用连接。充满限制在某些情况下可能会搞砸了。
　　•VectorLine.SetColor 集后盖的颜色。
　　•VectorLine.GetPoint函数返回正确的点,如果画线与转换。
　　•行用Draw3DAuto不会生成错误消息时加载一个新的水平。
　　•使用纹理尺度与2 d线与转换了。
　　•使用纹理范围内正常工作与viewport坐标线绘制。
　　•结束上限3 d线正确的比例在使用(而不是Draw3D)。
　　•VectorLine.maxDrawIndex时夹正确设置。
　　•更新一些演示脚本正常工作时切换分辨率。
　　
　　- - - - - - - - - - - -
　　
　　Vectrosity 2.3
　　添加:
　　•VectorLine.MakeCube,让任意的数据集。
　　•VectorLine.Version函数,它返回一个字符串,该字符串包含版本信息,因为它并不总是显而易见的(例如,如果你使用DLL)。
　　
　　变化:
　　•VectorLine.Selected可以显示线段的索引(或者,如果使用VectorPoints)被选中,通过在一个索引变量中。注意,“Selected (point, extraDistance)“覆盖已不复存在;双参数现在版本是“Selected (point, index)“如果使用Unityscript和“选择(指出,指数)“在c#。你仍然可以使用extraDistance,但现在你必须使用索引,例如“Selected (point, extraDistance, index)”。在c#中,“Selected (point, extraDistance, out index)”。
　　•VectorLine.SetCameraRenderTexture可以使用一个可选的布尔值来指定使用一个直角的相机。
　　
　　修复:
　　•VectorLine.SetColor与VectorPoints能正常工作,和1个像素的线和点如果useMeshLines / useMeshPoints设置。。
　　•使用EndCap.Back 用Draw3D工作正常,并结束描述。如果后面的纹理结构有不同的方面比前面的纹理。
　　•VectorLine.Resize工作正常结束端点。
　　•VectorLine.Destroy与Draw3DAuto工作正常。
　　•VectorLine.Selected与drawStart / drawEnd选集。
　　•VectorLine.Selected与VectorPoints工作正常。
　　•VectorLine.Selected使用行用一个转换参数。
　　•使用minDrawIndex或maxDrawIndex与Joins.Fill 。填充和3 d线不再创建一个无关的三角形末端的线连接到Vector3.zero。
　　ectrosity 2.2
　　
　　添加:
　　•VectorLine.Selected,确定如果选择一条线,鼠标指针。如。”,“如果(Input.GetMouseButtonDown(0)& & myLine.Selected(Input.mousePosition)){打印(myLine.name +“点击!”);}“注意,输入坐标必须在屏幕空间(如Input.mousePosition提供的),没有GUI的空间(如由Event.current提供。mousePosition OnGUI内)。
　　•VectorLine.mesh,如果你想访问的实际啮合VectorLine. e.g如。“var bounds= myLine.mesh.bounds范围”。这是因为做“myLine.vectorObject.GetComponent .mesh(MeshFilter)。“创建问题。
　　•VectorLine.AddTangents将切线添加到线网,如果你使用一个材料,材质使用normalmapping.AddNormals.  AddTangents调用,如果它还没有被调用。
　　•更多字符添加到标准字符集(VectorChar.cs)。
　　变化:
　　•现在用三角形默认情况下统一4行,由于MeshTopology的事实。四管/线/点不工作始终在所有平台上。在这种情况下,你知道正确目标平台支持四胞胎或线或点,和你想使用它们,您可以把那些VectorLine。VectorLine useMeshQuads = true。useMeshLines = true,VectorLine。分别useMeshPoints = true。注意,这之前必须做的第一件事就是创建任何VectorLines,因为一旦VectorLine创建,用于画线的方法是改变不了的。
　　•改变颜色现在可以选择一个索引,或两个指数。在一个索引的情况下,它将特定线段设置为指定的颜色。所以如。“myLine。改变颜色(颜色。红色,3)“将第三段设置为红色。对于两个指标,从第一段指数包括第二索引将被设置为指定的颜色。所以“myLine。改变颜色(颜色。蓝色、2、7)“通过7日将第二段变成蓝色。
　　•AddNormals之前可以被称为现在画一条线。以前,先要画一条线AddNormals可以添加正确的信息。
　　•从标准的资产转移到插件文件夹中。所以,如果你从早期版本更新,您需要删除旧的版本。
　　修复:
　　•使用drawStart或drawEnd与连接。填充和3 d线不再创建一个无关的三角形末端的线连接到Vector3.zero。(实际上,应用于二维线,但不是在游戏视图可见似乎正确的在这种情况下。无论如何这是固定的)。
　　•使用结束帽和Draw3D现在能正常工作。
　　•统一Unity 4,VectorCam使用HDR如果主相机使用HDR,防止屏幕腐败。
　　•VectorLine.MakeText,试图使用字符集的字符不是不再会导致一个错误;相反,它的留空。
　　Vectrosity 2.1
　　
　　添加:
　　•VectorLine.SetEndCap设置上限额度,这样他们就可以有一个额外的纹理的前面,或背面,或两者兼而有之。用于制造线和箭头,或线、圆形的目的等。
　　•VectorLine.RemoveEndCap移除以前定义的后盖。
　　•VectorLine.endCap告诉一个特定的行描述使用一个特定的后盖SetEndCap设置。这些命名,例如:myLine.endCap = "arrow";
　　•VectorLine.continuousTexture,让纹理的瓷砖,均匀,线的长度,不管多少分线。如。e.g,myLine.continuousTexture = true;
    •VectorLine.SetCameraRenderTexture,告诉rendertexture指定的向量相机来呈现,而你可以选择提供一个背景颜色(否则将黑)。如。,VectorLine。SetCameraRenderTexture(myRenderTexture Color.blue);这样做之后,将所有行rendertexture和不正常的相机视图中可见。传递null Rendertexture将向量的相机恢复正常。如。,VectorLine.SetCameraRenderTexture(null);请注意,这个函数只能用于统一Pro,因为职业是Rendertextures所需。
　　变化:
　　•Vectrosity现在有自己的名称空间,所以脚本使用它应该导入命名空间。Unityscript和Boo,使用“import Vectrosity;”,c#,使用“using Vectrosity;”。
　　•The points 与VectorLine.MakeRect已经重新安排了离散线,所以它与Joins.Weld工作正常。(但不导致任何视觉差异。)
•一些优化了统一4特性,以便更少的内存用于线网格索引,因为四胞胎是用来代替三角形,再加上Color32可用于顶点颜色。线的厚度仅为1像素,使用实际的行而不是四胞胎,导致4 x加速当使用画(甚至更少的内存用于网格索引行)。注意:不需要统一4(3.4统一仍然是最低的)。源代码将致力于团结统一3或4。如果你使用。dll,然后有两个版本,一个用于统一3和一个用于统一Unity 4。另一个注意:目前,统一4 b9,有一个问题,iOS不会正确地呈现四胞胎。所以,如果你现在需要发布iOS使用统一4,您应该使用统一3。dll,它仍然使用三角形为我所做的一切。这个问题应该固定统一以后的版本4。
　　•与上述有关,当使用统一Uniry 4日Draw3DAuto没有必要对3 d线厚达1像素。最佳性能,只使用Draw3D,它将像Draw3DAuto。Draw3DAuto仍应被用于3 d线厚度超过1像素,或如果你使用统一3。
　　•GetPoint / GetPoint3D函数由一个线夹现在drawStart和drawEnd变量。
　　vectrosity 2.0.1
　　
　　变化:
　　•行用Draw3DAuto总是更新每一帧无论摄像机移动。
　　
　　修复:
　　•在VisibilityControl注释错误的注释行。
　　•通过时间钓鱼线等工作。
　　Vectrosity 2.0
　　
　　变化:
　　•一个大:向量类没有更多!相反,它是与VectorLine合并。这允许一个更好的体系结构中,一般更易于使用,一些轻微的性能改进,它不与Flash中的向量类冲突。不利的一面是,它打破了几乎所有以前的代码,使用Vectrosity。所以不是微不足道的。(这就是为什么这是版本2.0)。将代码转换为新系统的好处是相当简单;看到Vectrosity升级指南。例如,Vector.DrawLine(myLine)成为myLine.Draw()。花了不到十分钟就把所有的演示脚本。
　　
　　•DrawPoints也消失了,但不要惊慌:相反,画和Draw3D将VectorPoints和VectorLine。
　　•Draw3DAuto现在也VectorPoints和VectorLine工作。
　　•VectorManager.ObjectSetup可以使用行用VectorPoints VectorLine一样。
　　•当使用Joins.Fill,你不再需要考虑分数组的第一个和最后一个点是否在比赛,因为这是自动处理的。第一个和最后一个点可以在任何时间,相同或不同的,它永远是正确的。
　　•ZeroPoints(原ZeroPointsInLine)可以使用一个指数除了一开始指数结束,所以你可以删除一个范围,而不是总是结束的点阵列。
　　•现在LineMaker实用程序有一个按钮加载早先保存文件。
　　•LineMaker实用程序将列出任何选择的指数线部分,所以你可以使用此信息诸如设置特定颜色的特定行段在一个向量对象。
　　添加:
　　•VectorLine.drawStart VectorLine.drawEnd来画线的部分。这是不同于minDrawIndex maxDrawIndex,只优化更新的一部分一行当的其余部分保持不变。相比之下,实际上使用drawStart和drawEnd绘制指定的范围和擦除其余的线,所以它可以用于诸如动画的一部分(见PartialLine示例场景)。
　　•VectorLine的加入可以改变使用VectorLine.joins在任何时候。即。i.e,myLine.joins= Joins.Fill。(记住连接…如的局限性。,试图设置一个离散的行连接。填补不会做任何事情。)
　　•VectorLine.maxWeldDistance使用Joins.Weld maxWeldDistance防止工件。如果行段几乎平行,相交点焊接可以扩展太远,所以maxWeldDistance阻止通过取消焊接如果出现这种情况(线段)。默认情况下,maxWeldDistance厚度的两倍行创建时指定行。
　　•VectorLine.material在任何时候改变VectorLine的材料,而不是创建线时。如。e.g,myLine.material= newMaterial;
　　•VectorLine.AddNormals将法线添加到线网,如果你使用一个材料,材质需要法线。如e.g,myLine.AddNormals();
　　•VectorLine.GetCamera,它返回向量相机SetCamera。(SetCamera也返回这个相机,但你可以在任何时候使用GetCamera)。
　　•Vectrosity核心脚本是作为一个提供。dll以及源代码。这可以在某些情况下更方便使用。使用它,Vectrosity副本。dll导入VectrosityCore统一项目而不是包。(注意,LineMaker实用程序的一部分。dll,所以你仍然需要导入VectrosityCore包如果你想使用。如果你使用。除了LineMaker dll,您可以取消选择所有。js脚本在导入VectrosityCore包。)
　　修复:
　　•minDrawIndex工作正常连续线由Vector3点。
　　•固定MissingReferenceException错误当在编辑器中使用ObjectSetup时停止播放模式。
　　•固定情况下Joins.Weld。焊缝有时没有焊接回路中第一个和最后一个点,如果他们是相同的。
　　Vectrosity 1.5
　　
　　添加:
　　•Vector.MakeWireframeInLine,进行自动网格线框图。本质上是一样的,如果你使用LineMaker实用程序的对象,并点击“连接所有点”,除了在运行时您可以使用它在任意网格。(注意:不是动画网格,对不起,那是不可能的,因为动画状态网格不能阅读在统一。)
　　•Vector.DrawLineViewport,绘制2 d线和规范化viewport坐标。这对GUIText和GUITexture作品像坐标,在左下角(0.0,0.0),(1.0,1.0)是右上角。这意味着与DrawLineViewport线条画将在相同的相对位置,无论屏幕分辨率。e。使用[Vector2(g。5,5),Vector2(1.0,5)]总是导致一行在屏幕的中间开始,终止于正确的边缘。
　　•Vector.GetLinePoint和Vector.GetLinePoint3D,获得一个职位在一个基于长度的2 d或3 d线。可用于诸如使物体沿着样条以恒定速度。
　　•Vector.GetLinePoint01和Vector.GetLinePoint3D01:如上所述,但是您可以使用一个0 . .1长度百分比而不是单位长度。如。中途,使用0.5返回一个点。
　　•Vector.GetLineLength,它返回一个给定的线的总长度。
　　•Vector.SetLineDistances:使用这个如果你改变任何点的位置VectorLine使用GetLineLength后,GetLinePoint等等,想再次使用这些功能。由于性能原因这不是自动完成。
　　•除了用于GameObject和网的名字,现在的“name”属性直接用于VectorLines。如。Debug.Log(myLine.name);。改变VectorLine名称属性将改变GameObject适当和网格名称。
　　变化:
　　•需要统一3.4。
　　•VectorLine.Active被Vector.Active 所取代。活跃的,所以更符合统一的运作方式。如。,myLine。积极= false。
　　•Vector.SetColorsSmooth现在可以使用即使不是最初创建的颜色。
　　•Vector.SetWidths现在可以使用int数组的行宽度(而不是只浮点数组)。
　　•VectorLine。现在continuousLine VectorLine。连续,因为“continuousLine”是冗余的上下文。
　　修复:
　　•Vector.DestroyLine与VectorPoints再次一起工作。
　　•旋转和尺度对象使用LineMaker实用程序是正确尊重当生成行。
　　Vectrosity 1.4.2
　　
　　变化:
　　•传入null时的默认使用的材料为线材料与透明度好。
　　•Vector.MakeTextInLine可以使用Vector3开始位置(使用Vector3点行)。
　　
　　修复:
　　• Joins.Weld。焊接与DrawLine3D正常。
　　•MakeTextInLine作品如果是数组,使用文本的确切数字所需的点数量(如果MakeTextInLine叫两次这将发生在同一VectorLine相同的文本,例如)。
　　Vectrosity 1.4
　　
　　添加:
　　• Joins.Weld。焊接,焊接线之间的顶点段。这使得优质粗线在使用纹理时,由于连接。用单色线填充只看起来不错。此外,与连接。填补,离散线可以使用连接。焊接,线段的终点在哪里等于未来将焊接的起始点。连接。然而,填充速度更快。
　　•minDrawIndex maxDrawIndex VectorLines的属性,所以你可以很容易地更新一条线的一部分。这适用于向量。SetColors以及各种画直线和DrawPoints功能。
　　• Joins.WeldDrawLine3DAuto,让3 d线自动总是更新正确不管相机运动。这样你不需要经常更新行向量。DrawLine3D自己了……你可以只调用一次DrawLine3DAuto并忘记它。
　　•Vector.StopDrawingLine3DAuto,以防您希望DrawLine3DAuto停止自动升级。
　　•Vector.MakeSplineInLine让Catmull-Rom样条函数,所以你可以设置任意数量的点,和合成曲线将通过这些点。
　　•Vector.Active,所以你可以禁用和启用线路不破坏和重建。
　　•Vector.DrawPoints3D,像DrawLine3D但对点。
　　•Vector.SetRay和Vector.SetRay3D相当于调试。DrawRay,在构建工作。如。、“Vector.SetRay(颜色。绿色转变。位置,transform.forward * 5.0);“当然,SetRay画标准覆盖线和SetRay3D场景中画一条线。
　　•Vector.GetSegmentNumber告诉你有多少行段在给定VectorLine是可能的。(只是一个小便利功能;节省你不必记得points-1连续线和离散点/ 2线)。
　　•更多VectrosityDemos包示例脚本和场景。
　　变化:
　　•Vector.MakeCircleInLine和Vector.MakeEllipseInLine可以把一个向量,所以圆形/椭圆形在3 d空间可以面向任何飞机,而不是X / Y平面。
　　•包括小写字母用于Vector.MakeTextInLine,所以你不需要自己做。
　　•段帽长度和线深度参数声明VectorLines时已被移除。在实践中,这些通常都保持默认,因此包括他们的宣言让事情更加复杂,超出了必要的范围。如果您需要指定这些,你可以设置line.capLength和line.depth深度属性相反,行后宣布。如果你从旧版本升级,这可能会导致一些代码破损,但很容易解决,使宣布VectorLines更好的从现在开始。
　　•Vector.SetLayer被移除。如果你需要设置层,使用VectorLine.layer,如“myLine。层= 16;”。
　　•Vector.SetDepth现在只适用于标准转换,不是VectorLines.设置线的深度,使用VectorLine.depth。如。”,myLine。= 10;深度”。
　　•Vector.DestroyLine和Vector.DestroyObject需要使用“ref”VectorLines现在在使用c#。如。”向量。DestroyLine(ref myLine);“
　　•BoundsMaker编辑器脚本。无形的边界网格,现在在必要时自动创建。如果你做任何边界网格,你可以删除它们,因为他们不习惯了。如果你想要一个GameObject使用标准网格,并没有将其替换为一个网格,将“false”添加到使用ObjectSetup时的参数。
　　•它不再是必要VectorManager脚本附加到场景中的一个对象要使用VectorManager功能。如果你从旧版本升级,VectorManager附加到一个对象,你应该删除它。
　　•Joins.Open 移除;使用Joins.Open 没有一个不是……这是种愚蠢的有两个枚举值,也做了同样的事情。同时,可见性。NotControlled删除(使用Visibility.None)以及亮度。正常(使用Brightness.None)。
　　•Vector.SetColor 和 Vector.SetColors现在可以使用即使不是最初创建的颜色。
　　•VectorPoints现在可以用Vector3数组。
　　•MakeCircleInLine等与点正常工作。
　　•DrawLine3D vectorLines利用向量。默认vectorLayer3D(vectorLayer3D默认为0)。这意味着混合画直线DrawLine3D将正常工作,而且你不需要惹手动设置层的线。如果你想VectorLines使用DrawLine3D使用另一个默认层除了0,然后做“向量。vectorLayer3D = x,其中x是你想要的层。你仍然可以使用VectorLine。层线呈现在任何给定的层。
　　•Vector.SetTextureScale可以改变通过现在,这样它将与线路正常工作与转换了。
　　　　•Vector.SetCamera返回向量相机现在,所以,如果你正在做的事情与向量相机,你可以只做“var vectorCam = Vector.SetCamera();“使用GameObject.Find等等。
　　•如果有多个行宽度,设置VectorLine.LineWidth导致所有宽度有价值。
　　•SetLine和SetLine3D现在可以实现时间价值,因此他们被指定的秒数,然后销毁。如。、“Vector.SetLine(颜色。红色,5.0,Vector3。零,Vector3(5、5、5));“(也适用于DrawRay DrawRay3D。)
　　•MakeCircleInLine短形式的、MakeEllipseInLine MakeCurveInLine,MakeSplineInLine,您可以进一步离开段的数量,并将用整个现有点阵列的线。
　　•VectorManager.ObjectSetup可以用来添加/删除的可见性和亮度脚本。如。”,VectorManager.ObjectSetup(gameObject线,可见性。动态、Brightness.None);“删除亮度。雾如果它被设置。
　　•删除VectorManager.DestroyObject因为不再需要。
　　修复:
　　•使用Joins.FIll 填充DrawLine3D现在工作正常(也加入。填补更有效)。
　　•当使用Vector.SetTextureScale 3 d线,如果SetCamera3D尚未建立,它会自动被称为而不是生成一个错误。
　　•再次设置VectorLine.lineWidth的作品(破碎Vectrosity 1.3)。
　　•固定多个线段宽度在某些情况下受到不正确。
　　•使用SetTextureScale线有多个宽度现在工作正常。
　　Vectrosity 1.3
　　
　　添加:
　　•VectorLine.Resize改变段的数量构成一条线,而不是摧毁并重建它。
　　•Vector.MakeCharsInLine让文本向量。
　　•Vector.SetWidths制定每一行的像素宽度VectorLine.Pass传入的数组floats、每个线段一个条目。
　　•VectorLine.smoothWidth线段宽度是否应该被内插段之间。
　　变化:
　　•Vector.SetTextureScale和Vector.ResetTextureScale工作于3 d线以及2 d线。
　　•一些杂小的明显变化;画线2 - 5%速度取决于功能。
　　•VectorLine.vertexColors改为VectorLine.lineColors,使它符合lineVertices和lineUVs。
　　•改进文档。
　　•简单处理3 d矢量对象使用VectorManager函数,由于统一OnDestroy 3.2。
　　修复:
　　•VisibilityControlStatic占旋转对象。
　　
　　- - - - - - - - - - - -
　　
　　Vectrosity 1.2
　　
　　添加:
　　•Vector.SetColorsSmooth让线段颜色之间插入片段。
　　•Vector.SetLine 和 Vector.SetLine3D制作基本线尽可能简单。
　　•VectorPoints类,使用Vector.DrawPoints不需要以前的黑客。
　　•一个新的示例脚本在VectrosityDemos包:DrawLinesTouch,触摸屏竞聘。
　　变化:
　　•传入的“空”将使用默认的材料,能正常工作的顶点颜色和深度参数。有用的,如果你只需要一个标准的材料没有任何纹理。
　　•现在Vector.SetCamera是可选的。它会要求你在必要的时候,只要你的相机是“Main Camera”标记。(如果不是,您仍然可以称之为手动)。
　　•Vector.MakeCurveInLine,Vector.MakeRectInLine和Vector.MakeCircleInLine / MakeEllipseInLine为3 d线以及2 d线工作。
　　•Vector.SetCamera有一个额外的参数,useOrtho(缺省为false),这使得矢量相机是直角的。这可以使线条呈现更准确,但与3 d线在某些情况下可能会导致异常。
　　•动态类型从DrawCurve从VectrosityDemos包中删除,因此它将建立在移动设备。
　　Vectrosity 1.1
　　
　　添加:
　　•Vector.MakeCircleInLine 和Vector.MakeEllipseInLine。
　　•Vector.MakeCurveInLine 贝塞尔曲线。
　　•Vector.SetTextureScale制定一个统一的结构,用于点缀dashed/etc. lines。
　　•Vector.ResetTextureScale如果您想重置线使用SetTextureScale uvs后恢复正常。
　　•Vector.DrawLine3D绘制3 d矢量线在三维空间中,在那里他们可以阻挡3 d对象。
　　•Vector.SetCamera3D设置相机专门为3 d线。在这种情况下不使用标准向量相机。
　　•Vector.SetLayer设置层的3 d线,如果你想混合正常线与3 d线，那么你使用SetCamera代替SetCamera3D
　　•Vector.SetVectorCamDepth制定向量的深度相机(惊喜!)。而不是设置Vector.cam.depth,因为向量.cam现在是私有的。
　　•VectorManager.useDrawLine3D 告诉VectorManager useDrawLine3D变量是否应该使用DrawLine3D与否。
　　•VectorManager.DestroyObject破坏了3 d vectorline对象。
　　•VectrosityDemos的一些新的例子脚本包。
　　变化:
　　•删除从MakeRectInLine线型参数。相反,行类型是捡起自动从传入的线,似乎没有理由手动指定它。
　　•LineMaker现在部队字符串使用期限小数,修复问题的一些欧洲用户。如果这种行为不是出于某种原因,删除第一行的初始化函数LineMaker脚本(CurrentCulture东西的线)。
　　•额外的定义2 d VectorLines过载:默认后盖宽度是0.0,所以如果你不使用它,你可以像“VectorLine("Name", linePoints, material, width)0.0“无需把后盖。
　　•这更多的是一个内部的事情,但如果有人使用这些:VectorLine.use2Dlines消失了(检查是否points2 not null),和VectorLine.points is now VectorLine.points3(仅仅因为这是一个困惑的名字,因为它是一个Vector3数组,和points2 Vector2数组)。
　　
　　- - - - - - - - - - - -
　　
　　Vectrosity 1.0
　　
　　最初的版本。
　　
　　
